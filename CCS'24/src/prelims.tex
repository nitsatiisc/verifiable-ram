
Throughout the paper, we assume a bilinear group generator $\bg$ which on input $\lambda$ outputs
parameters for the protocols. Specifically $\bg(1^\secp)$ outputs $(\F,\Gone,\Gtwo,\GT, e, g_1, g_2,g_t)$
where:
\begin{itemize}[leftmargin=2em, label=-]
	\item $\F=\Fp$ is a prime field of super-polynomial size in $\lambda$, with $p=\lambda^{\omega(1)}$.
	\item $\Gone,\Gtwo$ and $\GT$ are groups of order $p$, and $e$ is an efficiently computable non-degenerate
	pairing $e:\Gone\times \Gtwo\rightarrow \GT$.
	\item Generators $g_1,g_2$ are uniformly chosen from $\Gone$ and $\Gtwo$ respectively and $g_t=e(g_1,g_2)$.
\end{itemize}
We write groups $\Gone$ and $\Gtwo$ additively, and use the shorthand notation $\gone{x}$ and $\gtwo{x}$
to denote group elements $x\cdot g_1$ and $x\cdot g_2$ respectively for $x\in \F$. We will implicity assume
that all the setup algorithms for the protocols invoke $\bg$ to generate descriptions of groups and fields
over which the protocol is instantiated. We will use the notation
$[n]$ to denote the set of integers $\{1,\ldots,n\}$.

\noindent{\bf Security Model}: We describe public-coin interactive protocols, involving a prover and a verifier,
where both the parties have access to a structured reference string (SRS). The SRS in our protocol consists of
encodings of monomials of the form $\left\{\gone{x^i}\}_{a\leq i\leq b}$, $\left\{\gtwo{x^i}\}_{c\leq i\leq d}$
for $x$ chosen uniformly from $\F$ and $a,b,c,d$ are bounded by some polynomial in $\lambda$. It then follows
from ~\cite{EPRINT:BowGabMie17} that such an SRS can be generated using a universal and updatable setup requiring
only one honest participant. In practice, this gives us a far superior security model to the one requiring a fully
trusted setup. We use $\srs = (\srs_1,\srs_2)$ to denote the structured reference string of the above form. We say
that the $\srs$ has degree $Q$ if all the elements of $\srs_i$, $i=1,2$ are of the form $[f(x)]_i$ for a
polynomial $f\in \F_{<Q}[X]$.\smallskip


\noindent{\bf Algebraic Group Model}: We analyse our protocols in the Algebraic Group Model (AGM) introduced
in ~\cite{C:FucKilLos18}. We consider {\em algebraic adversaries} $\Adv$, which in our SRS-based protocol means
an efficient algorithm satisfying the following:
\begin{itemize}[leftmargin=1em]
	\item For $i\in \{1,2\}$, whenever $\Adv$ outputs an element $A\in \G_i$, it also outputs a vector $\vec{v}$
	over $\F$ such that $A=\langle \vec{v},\srs_i\rangle$.
\end{itemize}
Algebraic group model is a useful framework for obtaining succinct arguments of knowledge (SNARKs) from interactive
protocols described as {\em polynomial protocols} ~\cite{Gabizon2019PLONKPO}. Informally, the prover's messages in
a polynomial protocol are low degree polynomials, and the verifier accepts or rejects by checking certain identities
over polynomials output by the prover and possibly public polynomials known to the verifier. A polynomial protocol can
be compiled into a succinct argument of knowledge by using an extractable polynomial commitment scheme, which allows a
prover to send commitments to polynomials, and later send evaluation proofs for the same to enable the verifier to probabilistically
check polynomial identities at random points of $\F$. We refer the reader to ~\cite[Section 4.2]{Gabizon2019PLONKPO} for details
on polynomial protocols and their compilation to SNARKs in the algebraic group model.

\subsection{KZG Commitment Scheme}
\label{sec:KZG}
We use the $\kzg$ commitment scheme introduced in ~\cite{AC:KatZavGol10} which satisfies succinctness, completeness and knowledge-soundness (extractability)
in the algebraic group model, while additionally featuring a universal and updatable setup. We denote the $\kzg$ scheme by the tuple
of $\ppt$ algorithms $(\KZGsetup$,$\KZGcommit$, $\KZGopen$, $\KZGverify)$ as defined below.
%We then establish the isomorphism of the KZG polynomial commitment scheme as a vector commitment scheme.
\begin{definition}[KZG Polynomial Commitment Scheme]
	Let $(\F,\Gone,\Gtwo,\GT, e, g_1, g_2, g_t)$ be output of bilinear group generator $\bg(1^\secp)$ for security parameter $\secp$.
	The KZG polynomial commitment scheme is defined as follows:
	\begin{itemize}[leftmargin=1em]
		\item $\KZGsetup$ on input $(1^\secp,d)$, where $d$ is the degree bound, outputs
		$\srs = \{\eltone{\tau},\ldots,\eltone{\tau^d}\}$ ,$\{\elttwo{\tau},\ldots,\elttwo{\tau^d}\}$.
		\item $\KZGcommit$ on input $(\srs,p(X))$, where $p(X) \in \F_{\leq d}[X]$, outputs $C=\eltone{p(\tau)}$
		\item $\KZGopen$ on input $(\srs,p(X),\alpha)$, where $p(X) \in \F_{\leq d}[X]$ and $\alpha\in \F$, outputs $(v, \pi)$ such that $v=p(\alpha)$ and $\pi=\eltone{q(\tau)}$, for
		\[ q(X)=\frac{p(X)-p(\alpha)}{X-\alpha} \]
		\item $\KZGverify$ on input $(\srs,C,\alpha,v,\pi)$, outputs $1$ if the following equation holds, and $0$ otherwise.
		\[ e(C-v, \elttwo{\tau}) = e(\pi, \elttwo{\tau-\alpha}) \]
	\end{itemize}
\end{definition}

We also assume (w.l.o.g) analogues of $\KZGcommit$, $\KZGopen$ and $\KZGverify$ defined over the group $\Gtwo$.
We shall use the (non-standard) notation $[p(X)]_i$ to denote $[p(\tau)]_i$ for $i\in \{1,2\}$.
This allows us a convenient shorthand for referring to ``commitment of the polynomial $p(X)$'' in group $\G_i$.
Our protocols also use batched KZG proofs to show that polynomial $p(X)$ satisfies $p(\alpha_i)=v_i$ for $i\in [n]$. Let
$\vec{\alpha}=(\alpha_1,\ldots,\alpha_n)$
denote the vector of evaluation points and $\vec{v}=(v_1,\ldots,v_n)$ denote the vector of claimed evaluations. Then the batched
version of $\KZGopen$ is described as follows:
\begin{itemize}[leftmargin=1em]
	\item $\KZGopen$ on input $(\srs,p(X),\vec{\alpha})$, where $p(X) \in \F_{\leq d}[X]$ and $\vec{\alpha}\in\F^n$,
	outputs $(\vec{v}, \pi)$ with $\vec{v}\in \F^n$ such that $v_i=p(\alpha_i)$ and $\pi=\eltone{q(\tau)}$ where
	\[ q(X)=\frac{p(X)-r(X)}{a(X)} \]
	In the above, $a(X)=(X-\alpha_1)\cdots(X-\alpha_n)$, while $q(X)$ and $r(X)$ are the quotient and remainder polynomials when
	 $p(X)$ is divided by $a(X)$.
	%Note that the polynomials $a(X)$ and $r(X)$ can be computed by the verifier since $\{\alpha_i,v_i\}_{i\in [n]}$ are known and
	%$a(X)=(X-\alpha_1)\cdots(X-\alpha_n)$ and $r(\alpha_i)=v_i$ for all $i\in [n]$ such that $0\leq \deg(r(X)) \leq n$.
	\item $\KZGverify$ on input $(\srs,C,\vec{\alpha},\vec{v},\pi)$, outputs $1$ if the following equations holds, and $0$ otherwise.
	\begin{align*}
		e(C-\eltone{r(\tau)}, \elttwo{\tau}) &= e(\pi, \elttwo{a(\tau)})
	\end{align*}
	Here, the verifier interpolates the polynomial $r(X)\in \F_{<n}[X]$ such that $r(\alpha_i)=v_i$.
\end{itemize}

%\begin{definition}[KZG Polynomial Commitment Scheme \textcolor{red}{degree check included}]
%    Let $(p,\Gone,\Gtwo,\GT, e, \eltone{1},\elttwo{1})$ be a bilinear group. The KZG polynomial commitment scheme is defined as follows: 
%    \begin{itemize}
%	        \item $\KZGsetup$ on input $(1^\lambda,d)$, where $\lambda$ is the security parameter and $d$ is the degree bound, outputs $\srs = \{ \eltone{\tau},\ldots,\eltone{\tau^d},\elttwo{\tau},\ldots,\elttwo{\tau^d}\}$
%	        \item $\KZGcommit$ on input $(\srs,p(X))$, where $p(X) \in \F_{\leq d}[X]$, outputs $C=\eltone{p(X)}:=\eltone{p(\tau)}$
%	        \item $\KZGopen$ on input $(\srs,p(X),\alpha)$, where $p(X) \in \F_{\leq d}[X]$ and $\alpha\in \F$, outputs $(v, \pi)$ such that $v=p(\alpha)$ and $\pi=\Comtwo{q(X)}:=\elttwo{q(\tau)}$, for
%	        \[ q(X)=\frac{p(X)-p(\alpha)}{X-\alpha} \]
%	        \item $\KZGverify$ on input $(\srs,C,\deg,\alpha,v,\pi)$, outputs $1$ if the following equation holds, and $0$ otherwise.
%	        \[ e(C-v, \elttwo{\tau}) = e(\pi, \elttwo{\tau-\alpha}) \]
%	        { \color{teal} \moumita{var 3.}
%		        Degree check has not been added. With degree check, $\pi$ is modified with
%		        \[ q(X)=X^{d-\deg(p(X))+2}\frac{p(X)-p(\alpha)}{X-\alpha} \]
%		        and the verification equation if modified as 
%		        \[ e(C-v, \elttwo{\tau}^{d-\deg+2}) = e(\pi, \elttwo{\tau-\alpha}) \]
%		        } %stays unchanged from var 1
%	    \end{itemize}
%\end{definition}
\nitin{Defer the commitment to vectors to where we need it}
\begin{comment}
\paragraph{Vector Commitment Scheme.} We note that there is a natural isomorphism between the set of vectors of length $n$ and polynomials of degree $n-1$, where any vector $\abf=(a_1,\ldots,a_n) \in \F^n$ has a natural equivalent representation as a polynomial $a(X)=a_1\lambda_1(X)+\ldots,a_n\lambda_n(X)$, where $\{\lambda_i(X)\}_{i\in [n]}$ is basis of $\F_{\leq n-1}[X]$. Hence, when we use the KZG polynomial commitment scheme for a vector $\abf=(a_1,\ldots,a_n) \in \F^n$, we can output the commitment as $\KZGcommit(\srs,a(X))$, where $a(X)=a_1\lambda_1(X)+\ldots,a_n\lambda_n(X)$.


Now, for vectors of length $n$, we consider the basis $\{\lambda_i(X)\}$ to be the langrange basis with respect to the set consisting of $n^{th}$ roots of unity $\doubleH=\{\omega,\ldots,\omega^n\}$. The lagrange basis helps us use the property that, for some $i\in [n]$ and a value $\alpha$, $a(\omega^i)=a_i=\alpha$ if and only if there exists a polynomial $W(X)$ such that $W(X)=\frac{a(X)-\alpha}{X-\omega^i}$. 
\end{comment}
%Throughout the draft, for $\abf\in \F^n$, we use $\Comone{.}$ to denote $\KZGcommit(\srs,\abf)$ for vectors of length $n$, using the langrange polynomial basis $\{\lambda_i(X)\}$, with respect to the $n^{th}$ root of unity $\omega$, and for $\bbf \in \F^m$, we use $\Comtwo{.}$ to denote $\KZGcommit(\srs,\bbf)$ for vectors of length $m$, using the langrange polynomial basis $\{\mu_i(X)\}$, with respect to the $m^{th}$ root of unity $\nu$.